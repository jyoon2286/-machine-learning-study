## How do I get a good movie recommendation – Collaborative Filtering

## Abstract
As we were briefly introduced to a recommendation problem as an example for one of the optimization problems during the class, I thought that this project would be a great opportunity to find out how I get a good recommendation when I watch YouTube and Netflix and how can we solve optimization methods using methods that we were throughout the course. This project is focusing on implementing two collaborative filtering methods as Item-based Collaborative Filtering (CF) and Latent factor to get a movie recommendation.

## INTRODUCTION & MOTIVATION
Probably, most people, whether they recognize it or not, have experienced at least one recommendation algorithm in our life. For example, when you visit Amazon for shopping, you can see that the item is recommended to visitors, or when you click to get information on a specific product, you can select a product in various ways, such as recommended items, popular items, and items you may like. Another recommendation example is that you would ask for a review to your friends about the new movie if they already watched the movie before.
According to an interview with The New York Times, Neal Mohan, YouTube's Chief Product Officer, said, '70% of YouTube users' viewing time is the result of the recommendation algorithm, and the introduction of the algorithm increases the total video viewing time by more than 20 times than before [1]. Netflix also revealed through self-assessment that 75% of sales are generated by the referral system [2]. In other words, these two video platforms have strong algorithms to recommend perfect videos to users and personalized content. It can be said that they are guarding the throne even at present when the online video platform opponents appear one after another.
Collaborative Filtering (CF) is a technique of recommending a product or contents when other users similar to a specific user give good evaluations or if there is a good evaluation on other products similar to a specific product. There are two types of collaborative filtering: Nearest neighbor and Latent factor. There are many Collaborative Filtering (CF) research, methods, and developments that provide recommendation systems to. I found and used resources that are similar to this topic, especially, Abhinav Ajitsaria’s “Real Python” blog, “Build a Recommendation Engine With Collaborative Filtering” [3] and one of class from Carnegie Mellon University, “Matrix Factorization and Collaborative Filtering”, taught by Matt Gormley [4], which is the resources I refer to the most for this optimization problem.
In this project, I explore one of the types of Nearest neighbor methods, Item-based CF, but mainly focus on solving Latent factor, which is about using Singular value decomposition (SVD) and Gradient descent method to optimize the cost function so that the predicted vector R-value based on the vectors P and Q have the least error with the actual R-value. The dataset contains the 100,000 ratings and 3,600 tag applications applied to 9,000 movies by 600 users from the education and development version of MovieLens at Grouplens.org [5].

## CONCLUSION
I now know the Collaborative Filtering system, User-based CF, Item-based CF, and Latent factor methods which are one of methods in recommending system. I’m sure this is relatively simple, and the real-life problems that Netflix or YouTube use way more complex than this problem, but I get my foot into it and learn a new thing about the system. The predicted score shows that the Latent factor would give a better recommendation based on these methods, but I’m not able to check if those are. I’m surprised that two different methods give me different results which there is not a single common movie between the two methods. This project also helps me to understand better the gradient descent method especially the Stochastic Gradient Descent (SGD) method, and the Singular Vector Decomposition (SVD) is one of the ways that people use to win Netflix recommendation competition [8]. Last but not least, I learn how optimization problems can prevent overfitting the data and how important they are to solve machine learning problems.
